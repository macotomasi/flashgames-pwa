# üõ°Ô∏è Architecture S√©curis√©e Progressive FlashGames PWA

## üìä Approche Pragmatique de la S√©curit√©

Une s√©curit√© **modulaire et progressive** adapt√©e aux besoins r√©els d'une application √©ducative gamifi√©e, sans sur-ing√©nierie.

---

## üéØ Phase 1 : MVP S√©curis√© (Semaines 1-8)

### **1. Authentification Simple & Flexible**

```typescript
// auth-mvp.service.ts
interface AuthStrategy {
  type: 'guest' | 'email' | 'social'
  persistence: 'session' | 'local'
}

class SimplifiedAuthService {
  // Mode invit√© pour acc√®s rapide
  async continueAsGuest(): Promise<GuestSession> {
    const guestId = `guest_${crypto.randomUUID()}`
    const session = {
      id: guestId,
      type: 'guest' as const,
      createdAt: Date.now(),
      expiresAt: Date.now() + 30 * 24 * 60 * 60 * 1000 // 30 jours
    }
    
    // Stockage simple, pas de chiffrement pour les invit√©s
    localStorage.setItem('guestSession', JSON.stringify(session))
    return session
  }
  
  // Auth sociale simplifi√©e avec Auth0
  async loginWithSocial(provider: 'google' | 'apple'): Promise<UserSession> {
    const auth0Result = await this.auth0.loginWithPopup({
      connection: provider,
      scope: 'openid profile email'
    })
    
    // JWT dans la m√©moire, pas dans localStorage
    return {
      user: auth0Result.user,
      token: auth0Result.idToken,
      expiresAt: auth0Result.expiresIn * 1000 + Date.now()
    }
  }
  
  // Conversion invit√© ‚Üí compte
  async upgradeGuestAccount(guestId: string, authData: AuthData): Promise<void> {
    const guestData = await this.getGuestData(guestId)
    await this.mergeWithAccount(authData.userId, guestData)
  }
}
```

### **2. Stockage Pragmatique avec Gestion des Cl√©s**

```typescript
// key-management-mvp.service.ts
class SimpleKeyService {
  private readonly SALT_KEY = 'flashgames_salt_v1'
  
  // D√©rivation de cl√© renforc√©e
  async deriveUserKey(userId: string, deviceId?: string): Promise<CryptoKey> {
    const salt = await this.getOrCreateSalt()
    const keyMaterial = `${userId}:${deviceId || 'default'}:${salt}`
    
    // SHA-256 avant PBKDF2 pour meilleure entropie
    const encoder = new TextEncoder()
    const preDigest = await crypto.subtle.digest(
      'SHA-256', 
      encoder.encode(keyMaterial)
    )
    
    const baseKey = await crypto.subtle.importKey(
      'raw',
      preDigest,
      'PBKDF2',
      false,
      ['deriveKey']
    )
    
    return crypto.subtle.deriveKey(
      {
        name: 'PBKDF2',
        salt: encoder.encode(salt),
        iterations: 100000,
        hash: 'SHA-256'
      },
      baseKey,
      { name: 'AES-GCM', length: 256 },
      false,
      ['encrypt', 'decrypt']
    )
  }
  
  private async getOrCreateSalt(): Promise<string> {
    let salt = localStorage.getItem(this.SALT_KEY)
    if (!salt) {
      salt = btoa(String.fromCharCode(...crypto.getRandomValues(new Uint8Array(16))))
      localStorage.setItem(this.SALT_KEY, salt)
    }
    return salt
  }
}

// storage-mvp.service.ts
class PragmaticStorage {
  private keyService = new SimpleKeyService()
  private syncQueue: SyncQueueItem[] = []
  
  // R√©solution de conflits simple
  async saveWithConflictResolution(key: string, data: any): Promise<void> {
    const versionedData = {
      ...data,
      _version: Date.now(),
      _deviceId: await this.getDeviceId()
    }
    
    try {
      // Tentative IndexedDB
      await this.db.put(key, versionedData)
    } catch (e) {
      // Fallback avec gestion de version
      const existing = localStorage.getItem(key)
      if (existing) {
        const existingData = JSON.parse(existing)
        // R√©solution : priorit√© au plus r√©cent
        if (existingData._version > versionedData._version) {
          console.warn('Conflict detected, keeping newer version')
          return
        }
      }
      localStorage.setItem(key, JSON.stringify(versionedData))
    }
    
    // Ajouter √† la queue de sync
    this.syncQueue.push({
      key,
      data: versionedData,
      operation: 'update',
      timestamp: Date.now()
    })
  }
  
  // Journal de synchronisation
  async flushSyncQueue(): Promise<SyncResult> {
    if (this.syncQueue.length === 0) return { synced: 0 }
    
    const batch = [...this.syncQueue]
    this.syncQueue = []
    
    try {
      const result = await api.syncBatch(batch)
      return result
    } catch (error) {
      // Remettre en queue si √©chec
      this.syncQueue.unshift(...batch)
      throw error
    }
  }
}
```

### **3. S√©curit√© API Essentielle avec Validation Stricte**

```typescript
// api-security-mvp.ts
import { z } from 'zod' // ou joi/yup selon pr√©f√©rence

// Sch√©mas de validation centralis√©s
const schemas = {
  score: z.object({
    value: z.number().min(0).max(1000000),
    gameType: z.enum(['tetris', 'pacman', 'space-invaders', 'pong']),
    duration: z.number().min(10), // Minimum 10 secondes
    sessionToken: z.string(), // Token de session de jeu
    actions: z.array(z.object({
      type: z.string(),
      timestamp: z.number()
    })).optional()
  }),
  
  flashcard: z.object({
    front: z.string().min(1).max(500),
    back: z.string().min(1).max(1000),
    deckId: z.string().uuid()
  })
}

class MVPSecurityMiddleware {
  // JWT dans les headers uniquement (pas de CSRF n√©cessaire)
  authenticateJWT = (req: Request, res: Response, next: NextFunction) => {
    const token = req.headers.authorization?.split(' ')[1]
    
    if (!token) {
      return res.status(401).json({ error: 'No token provided' })
    }
    
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET)
      req.user = decoded
      next()
    } catch (error) {
      return res.status(403).json({ error: 'Invalid token' })
    }
  }
  
  // Rate limiting simple avec express-rate-limit
  basicRateLimit = rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 100,
    message: 'Too many requests'
  })
  
  // Validation stricte sur TOUTES les routes
  validateInput = (schemaName: keyof typeof schemas) => {
    return (req: Request, res: Response, next: NextFunction) => {
      const schema = schemas[schemaName]
      const result = schema.safeParse(req.body)
      
      if (!result.success) {
        return res.status(400).json({ 
          error: 'Validation failed',
          details: result.error.flatten()
        })
      }
      
      req.body = result.data // Donn√©es nettoy√©es
      next()
    }
  }
  
  // Validation automatique des query params
  validateQuery = (schema: z.ZodSchema) => {
    return (req: Request, res: Response, next: NextFunction) => {
      const result = schema.safeParse(req.query)
      if (!result.success) {
        return res.status(400).json({ 
          error: 'Invalid query parameters',
          details: result.error.flatten()
        })
      }
      req.query = result.data
      next()
    }
  }
}

// Routes avec validation obligatoire
app.post('/api/scores', 
  authenticate,
  validateInput('score'),
  async (req, res) => {
    // req.body est maintenant typ√© et valid√©
    const { sessionToken, ...scoreData } = req.body
    
    // V√©rifier le token de session
    const isValidSession = await verifyGameSession(sessionToken)
    if (!isValidSession) {
      return res.status(400).json({ error: 'Invalid game session' })
    }
    
    await saveScore(req.user.id, scoreData)
    res.json({ success: true })
  }
)

// Headers de s√©curit√© essentiels
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'"], // Pour React
      styleSrc: ["'self'", "'unsafe-inline'"],  // Pour Tailwind
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'", process.env.API_URL]
    }
  }
}))
```

### **4. Anti-Triche Offline-First avec Token de Session**

```typescript
// game-session.service.ts
class GameSessionService {
  private usedSessions = new Set<string>() // Blacklist temporaire
  
  // G√©n√©ration de token au d√©but de chaque partie
  async createGameSession(userId: string, gameType: GameType): Promise<GameSession> {
    const sessionId = crypto.randomUUID()
    const timestamp = Date.now()
    const nonce = crypto.randomUUID() // Nonce unique
    
    // Token sign√© c√¥t√© serveur avec nonce
    const sessionToken = jwt.sign(
      {
        sessionId,
        userId,
        gameType,
        startTime: timestamp,
        nonce, // Ajout du nonce
        exp: Math.floor(timestamp / 1000) + 3600 // 1h max
      },
      process.env.GAME_SESSION_SECRET
    )
    
    // Stocker la session pour validation ult√©rieure
    await this.storeSession({
      sessionId,
      userId,
      gameType,
      startTime: timestamp,
      nonce,
      token: sessionToken
    })
    
    return { sessionId, token: sessionToken }
  }
  
  // Validation du token avec invalidation apr√®s usage
  async validateScoreSubmission(
    sessionToken: string, 
    scoreData: ScoreSubmission
  ): Promise<boolean> {
    try {
      const decoded = jwt.verify(sessionToken, process.env.GAME_SESSION_SECRET) as any
      
      // V√©rifier si d√©j√† utilis√©
      if (this.usedSessions.has(decoded.sessionId)) {
        console.warn('Session token already used:', decoded.sessionId)
        return false
      }
      
      // V√©rifications de coh√©rence
      if (decoded.gameType !== scoreData.gameType) return false
      if (scoreData.duration < 10) return false // Minimum 10s
      
      const sessionDuration = Date.now() - decoded.startTime
      if (Math.abs(sessionDuration - scoreData.duration * 1000) > 5000) {
        // √âcart de plus de 5s entre dur√©e client et serveur
        return false
      }
      
      // Marquer comme utilis√©
      this.usedSessions.add(decoded.sessionId)
      
      // Nettoyer apr√®s 24h
      setTimeout(() => {
        this.usedSessions.delete(decoded.sessionId)
      }, 24 * 60 * 60 * 1000)
      
      return true
    } catch {
      return false
    }
  }
}

// anti-cheat-mvp.service.ts
class OfflineFirstAntiCheat {
  private sessionService = new GameSessionService()
  private eventBuffer: ClientEvent[] = []
  
  // D√©but de partie avec token et distinction online/offline
  async startGame(gameType: GameType): Promise<GameStartResult> {
    try {
      // Online : obtenir un token du serveur
      const session = await this.sessionService.createGameSession(
        this.getCurrentUserId(),
        gameType
      )
      return { 
        token: session.token,
        origin: 'online' as const
      }
    } catch {
      // Offline : token local temporaire
      const offlineToken = this.generateOfflineToken(gameType)
      return {
        token: offlineToken,
        origin: 'offline' as const
      }
    }
  }
  
  // Validation locale des scores avec origine
  validateScore(gameState: GameState, score: number, origin: 'online' | 'offline'): boolean {
    // R√®gles de coh√©rence basiques
    const maxPossibleScore = this.calculateMaxPossible(gameState)
    const minReasonableTime = this.getMinGameTime(gameState.gameType)
    
    // Limites plus strictes pour les scores offline
    if (origin === 'offline') {
      const offlineMaxScore = maxPossibleScore * 0.8 // 80% du max pour offline
      return score <= offlineMaxScore && 
             gameState.duration >= minReasonableTime * 1.5 // 50% plus de temps minimum
    }
    
    return score <= maxPossibleScore && 
           gameState.duration >= minReasonableTime
  }
  
  // Journal d'√©v√©nements suspects avec redaction PII
  logSuspiciousEvent(event: SuspiciousEvent): void {
    const anonymizedEvent = {
      type: event.type,
      severity: event.severity,
      timestamp: Date.now(),
      sessionId: this.getAnonymousSessionId(),
      details: this.redactPII(event.details) // Redaction automatique
    }
    
    // Buffer local limit√©
    this.eventBuffer.push(anonymizedEvent)
    if (this.eventBuffer.length > 50) {
      this.eventBuffer.shift() // FIFO
    }
    
    // Sync diff√©r√©e
    if (navigator.onLine && this.eventBuffer.length >= 10) {
      this.flushEvents()
    }
  }
  
  // Redaction des PII dans les logs
  private redactPII(data: any): any {
    const piiPatterns = {
      email: /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g,
      phone: /[\+]?[(]?[0-9]{3}[)]?[-\s\.]?[(]?[0-9]{3}[)]?[-\s\.]?[0-9]{4,6}/g,
      creditCard: /\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b/g
    }
    
    let sanitized = JSON.stringify(data)
    Object.entries(piiPatterns).forEach(([type, pattern]) => {
      sanitized = sanitized.replace(pattern, `[REDACTED_${type.toUpperCase()}]`)
    })
    
    return JSON.parse(sanitized)
  }
  
  // Audit p√©riodique avec quotas offline
  async syncAndAudit(userId: string): Promise<AuditResult> {
    const localScores = await this.getLocalScores(userId)
    const offlineScores = localScores.filter(s => s.origin === 'offline')
    const anomalies = []
    
    // Quota de scores offline
    if (offlineScores.length > 100) {
      console.warn(`User ${userId} has ${offlineScores.length} offline scores - triggering audit`)
      anomalies.push({
        type: 'excessive_offline_scores',
        count: offlineScores.length
      })
    }
    
    for (const score of localScores) {
      if (this.isAnomalous(score)) {
        anomalies.push(score)
        this.logSuspiciousEvent({
          type: 'score_anomaly',
          severity: score.origin === 'offline' ? 'high' : 'medium',
          details: { 
            score: score.value, 
            duration: score.duration,
            origin: score.origin
          }
        })
      }
    }
    
    // Envoi au serveur pour validation diff√©r√©e
    if (anomalies.length > 0) {
      await this.reportAnomalies(userId, anomalies)
    }
    
    return { 
      synced: localScores.length, 
      anomalies: anomalies.length,
      events: this.eventBuffer.length,
      offlineCount: offlineScores.length
    }
  }
  
  // Patterns suspects simples
  private isAnomalous(score: ScoreEntry): boolean {
    // D√©tection basique : scores impossibles, temps trop courts
    return score.value > 1000000 || 
           score.gameTime < 10 || 
           score.actionsPerMinute > 600
  }
  
  private async flushEvents(): Promise<void> {
    if (this.eventBuffer.length === 0) return
    
    try {
      await api.reportEvents(this.eventBuffer)
      this.eventBuffer = []
    } catch (error) {
      console.error('Failed to flush events:', error)
    }
  }
}
```

---

## üöÄ Phase 2 : S√©curit√© Renforc√©e (Mois 3-4)

### **1. Chiffrement S√©lectif et Segmentation des Donn√©es**

```typescript
// crypto-phase2.service.ts
class SelectiveCrypto {
  private keyService = new SimpleKeyService()
  
  // Convention : PII jamais en clair
  private piiGuard = new Proxy({}, {
    set: (target, prop, value) => {
      throw new Error('PII must be encrypted before storage')
    }
  })
  
  // Segmentation PII vs contenu p√©dagogique
  async encryptPII(userId: string, data: PersonalData): Promise<EncryptedData> {
    // Force l'utilisation du proxy en dev
    if (process.env.NODE_ENV === 'development') {
      Object.setPrototypeOf(data, this.piiGuard)
    }
    
    const deviceId = await this.getDeviceId()
    const key = await this.keyService.deriveUserKey(userId, deviceId)
    
    const iv = crypto.getRandomValues(new Uint8Array(12))
    const encrypted = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv },
      key,
      new TextEncoder().encode(JSON.stringify(data))
    )
    
    return {
      ciphertext: btoa(String.fromCharCode(...new Uint8Array(encrypted))),
      iv: btoa(String.fromCharCode(...iv)),
      type: 'PII'
    }
  }
  
  // Pas de chiffrement pour le contenu public
  async storeEducationalContent(content: EducationalContent): Promise<void> {
    await this.db.content.add({
      ...content,
      type: 'PUBLIC',
      checksum: this.calculateChecksum(content)
    })
  }
  
  // Export explicite par l'utilisateur
  async exportUserData(userId: string): Promise<ExportPackage> {
    const piiData = await this.getUserPII(userId)
    const scores = await this.getUserScores(userId)
    const flashcards = await this.getUserFlashcards(userId)
    
    return {
      version: '1.0',
      exportDate: new Date().toISOString(),
      data: {
        personal: piiData,
        learning: { scores, flashcards }
      },
      checksum: await this.generateExportChecksum({ piiData, scores, flashcards })
    }
  }
}

// data-segregation.service.ts
class DataSegregationService {
  // Tables s√©par√©es pour faciliter GDPR
  private piiTable = 'user_pii'
  private learningTable = 'user_learning'
  private publicTable = 'public_content'
  
  async deleteUserData(userId: string): Promise<void> {
    // Suppression PII imm√©diate
    await this.db.table(this.piiTable).where('userId').equals(userId).delete()
    
    // Anonymisation des donn√©es d'apprentissage
    await this.db.table(this.learningTable)
      .where('userId').equals(userId)
      .modify(record => {
        record.userId = `deleted_${crypto.randomUUID()}`
        record.anonymized = true
      })
  }
}
```

### **2. Monitoring L√©ger**

```typescript
// monitoring-phase2.service.ts
class LightweightMonitoring {
  // M√©triques anonymis√©es
  async trackUserBehavior(event: GameEvent): Promise<void> {
    const anonymizedEvent = {
      type: event.type,
      timestamp: Date.now(),
      sessionId: this.getAnonymousSessionId(), // Pas l'ID Auth0
      metadata: this.sanitizeMetadata(event.metadata)
    }
    
    // Buffer local avant envoi
    this.eventBuffer.push(anonymizedEvent)
    
    if (this.eventBuffer.length >= 50) {
      await this.flushEvents()
    }
  }
  
  // D√©tection d'anomalies simple
  detectSimpleAnomalies(userId: string): string[] {
    const warnings = []
    const recentActivity = this.getRecentActivity(userId)
    
    // R√®gles simples sans ML
    if (recentActivity.sessionsPerDay > 20) {
      warnings.push('Unusual session frequency')
    }
    
    if (recentActivity.avgScoreJump > 500) {
      warnings.push('Sudden score improvement')
    }
    
    return warnings
  }
}
```

---

## üíé Phase 3 : S√©curit√© Avanc√©e (Mois 6+)

### **1. Anti-Triche Serveur**

```typescript
// anti-cheat-phase3.service.ts
class ServerSideAntiCheat {
  // Validation diff√©r√©e des high scores
  async validateHighScore(scoreData: HighScore): Promise<ValidationResult> {
    // Replay simulation l√©g√®re
    const simulationResult = await this.lightweightReplay(scoreData.gameLog)
    
    // Comparaison statistique avec les autres joueurs
    const percentile = await this.calculatePercentile(scoreData)
    
    // Flag seulement les cas extr√™mes
    if (percentile > 99.9 && !simulationResult.valid) {
      return { valid: false, reason: 'Statistical anomaly' }
    }
    
    return { valid: true }
  }
}
```

### **2. Protection des Donn√©es Comportementales**

```typescript
// privacy-phase3.service.ts
class PrivacyCompliantAnalytics {
  // Consentement granulaire
  async requestAnalyticsConsent(): Promise<ConsentResult> {
    return {
      essential: true, // Toujours autoris√©
      performance: await this.askConsent('performance'),
      behavioral: await this.askConsent('behavioral')
    }
  }
  
  // Pseudonymisation
  generatePseudonymousId(userId: string): string {
    // ID opaque non r√©versible
    const salt = process.env.ANALYTICS_SALT
    return crypto.createHash('sha256')
      .update(userId + salt + new Date().toISOString().split('T')[0])
      .digest('hex')
      .substring(0, 16)
  }
}
```

---

## üìã Checklist de S√©curit√© Progressive

### **MVP (Obligatoire)**
```yaml
security_mvp:
  - [x] HTTPS partout
  - [x] Auth0 basique (social + invit√©)
  - [x] JWT dans headers (pas localStorage)
  - [x] Rate limiting simple
  - [x] Validation des inputs
  - [x] Headers de s√©curit√© (Helmet)
  - [x] Checksum pour l'int√©grit√©
```

### **Phase 2 (Recommand√©)**
```yaml
security_phase2:
  - [ ] Chiffrement des donn√©es priv√©es uniquement
  - [ ] Monitoring anonymis√©
  - [ ] Anti-triche offline avec sync
  - [ ] Backup/restore s√©curis√©
  - [ ] Audit de s√©curit√© basique
```

### **Phase 3 (Optimisation)**
```yaml
security_phase3:
  - [ ] Validation serveur des high scores
  - [ ] ML pour d√©tection d'anomalies
  - [ ] Conformit√© GDPR compl√®te
  - [ ] Pen testing professionnel
  - [ ] SOC 2 si B2B
```

---

## üéØ Architecture Simplifi√©e

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   CLIENT                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚Ä¢ Mode invit√© sans friction                ‚îÇ
‚îÇ  ‚Ä¢ Auth sociale optionnelle                 ‚îÇ
‚îÇ  ‚Ä¢ Stockage hybride (IndexedDB + fallback) ‚îÇ
‚îÇ  ‚Ä¢ Validation locale des scores             ‚îÇ
‚îÇ  ‚Ä¢ Sync diff√©r√©e offline-first             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                      ‚Üì
                   HTTPS
                      ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    API                       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚Ä¢ JWT validation (pas de CSRF)            ‚îÇ
‚îÇ  ‚Ä¢ Rate limiting basique                    ‚îÇ
‚îÇ  ‚Ä¢ Validation des inputs                    ‚îÇ
‚îÇ  ‚Ä¢ Audit p√©riodique (pas temps r√©el)       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                      ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 STOCKAGE                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚Ä¢ PostgreSQL (donn√©es utilisateur)         ‚îÇ
‚îÇ  ‚Ä¢ Redis (cache + rate limit)              ‚îÇ
‚îÇ  ‚Ä¢ Chiffrement s√©lectif c√¥t√© serveur       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üí° Principes Cl√©s Renforc√©s

1. **S√©curit√© appropri√©e** : Pas de sur-ing√©nierie pour une app √©ducative
2. **Progressive enhancement** : Commencer simple, √©voluer selon les besoins
3. **Offline-first** : PWA doit fonctionner sans connexion permanente
4. **Privacy by design** : Donn√©es anonymis√©es et segment√©es d√®s le d√©part
5. **User-friendly** : La s√©curit√© ne doit pas nuire √† l'exp√©rience
6. **Transparence** : Export explicite des donn√©es par l'utilisateur

## üß™ Mode D√©veloppement et Tests

### **Environnement de Test Anti-Triche**

```typescript
// dev-sandbox.service.ts
class DevSandboxService {
  // G√©n√©ration de triches pour tests
  async generateTestCheats(): Promise<CheatScenario[]> {
    return [
      {
        name: 'score_injection',
        action: () => this.injectHighScore(9999999),
        expectedDetection: true
      },
      {
        name: 'time_manipulation',
        action: () => this.manipulateGameTime(-5000),
        expectedDetection: true
      },
      {
        name: 'rapid_actions',
        action: () => this.simulateRapidClicks(1000),
        expectedDetection: true
      }
    ]
  }
  
  // Mode sandbox pour tests
  enableSandboxMode(): void {
    window.__SANDBOX_MODE__ = true
    console.warn('üß™ Sandbox mode enabled - cheats will not be reported')
  }
  
  // Validation des d√©tections
  async runAntiCheatTests(): Promise<TestResults> {
    const scenarios = await this.generateTestCheats()
    const results = []
    
    for (const scenario of scenarios) {
      this.enableSandboxMode()
      await scenario.action()
      
      const detected = await this.checkIfDetected(scenario.name)
      results.push({
        scenario: scenario.name,
        detected,
        passed: detected === scenario.expectedDetection
      })
    }
    
    return { results, passRate: this.calculatePassRate(results) }
  }
}
```

## üìã Configuration Modulaire

```typescript
// security.config.ts
interface SecurityConfig {
  phases: {
    mvp: {
      auth: {
        providers: ['guest', 'social'],
        mfa: false,
        sessionDuration: 30 * 24 * 60 * 60 * 1000 // 30 jours
      },
      encryption: {
        enabled: false,
        scope: ['tokens', 'sessions']
      },
      antiCheat: {
        clientValidation: true,
        serverValidation: false,
        sessionTokens: true
      },
      monitoring: {
        enabled: false,
        anonymousEvents: true,
        bufferSize: 50
      }
    },
    
    phase2: {
      auth: {
        providers: ['guest', 'social', 'email'],
        mfa: 'optional',
        biometric: true
      },
      encryption: {
        enabled: true,
        scope: ['pii', 'private_notes', 'payment_tokens'],
        keyRotation: 30 // jours
      },
      antiCheat: {
        clientValidation: true,
        serverValidation: true,
        anomalyDetection: 'simple',
        replayValidation: false
      },
      monitoring: {
        enabled: true,
        eventTypes: ['security', 'performance', 'errors'],
        gdprCompliant: true
      }
    },
    
    phase3: {
      auth: {
        providers: ['all'],
        mfa: 'recommended',
        passwordless: true,
        sso: true
      },
      encryption: {
        enabled: true,
        scope: 'all_sensitive',
        keyRotation: 7,
        quantumSafe: false // Future
      },
      antiCheat: {
        clientValidation: true,
        serverValidation: true,
        anomalyDetection: 'ml_based',
        replayValidation: true,
        behavioralAnalysis: true
      },
      monitoring: {
        enabled: true,
        siem: true,
        realTimeAlerts: true,
        complianceReports: true
      }
    }
  }
}

// Activation progressive
const currentPhase = process.env.SECURITY_PHASE || 'mvp'
const securityConfig = new SecurityConfig().phases[currentPhase]
```