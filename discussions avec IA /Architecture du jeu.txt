# Architecture FlashGames PWA - Version Compl√®te

## üìÅ Structure du Projet Adapt√©e

```
flashgames-pwa/
‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îú‚îÄ‚îÄ index.html
‚îÇ   ‚îî‚îÄ‚îÄ sounds/                    # Sons kawaii et victoires
‚îÇ       ‚îú‚îÄ‚îÄ line-clear.mp3
‚îÇ       ‚îú‚îÄ‚îÄ correct-answer.mp3
‚îÇ       ‚îú‚îÄ‚îÄ level-up.mp3
‚îÇ       ‚îî‚îÄ‚îÄ boss-warning.mp3
‚îÇ
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ layout/
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ flashcard/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FlashcardModal.tsx      # Modal avec "Je sais/Je ne sais pas"
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MultipleChoice.tsx      # QCM apr√®s la premi√®re r√©ponse
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BossQuestion.tsx        # Questions difficiles
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ FlashcardEditor.tsx     # Cr√©ation/modification
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ game/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ GameFrame.tsx           # Container responsive
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ GameOverlay.tsx         # Flashcards par-dessus le jeu
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ScoreBoard.tsx          # Score, statut, streak
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ StatusAvatar.tsx        # Avatar √©volutif
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ progression/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MemoryStatus.tsx        # Ver ‚Üí Einstein ‚Üí GPT
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DailyBadge.tsx          # Flash ‚Üí Univers
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ StreakCounter.tsx       # Jours cons√©cutifs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AchievementModal.tsx    # Popups de f√©licitations
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ deck/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ DeckManager.tsx         # Gestion des decks
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ DeckShare.tsx           # Export/import URL
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ DeckSelector.tsx        # Choix du deck
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ modules/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ flashcards/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ flashcard.service.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deck.service.ts         # ‚Üê Nouveau
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ fsrs/
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ fsrs-engine.ts
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ fsrs.worker.ts
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ fsrs-cache.ts
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ boss-cards.ts       # ‚Üê Nouveau : logique cartes difficiles
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ games/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ GameModule.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ game-flashcard.bridge.ts # ‚Üê Nouveau : int√©gration flashcards
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ implementations/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ tetris/
‚îÇ   ‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ tetris-game.ts
‚îÇ   ‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ tetris-logic.ts
‚îÇ   ‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ line-penalty.ts  # ‚Üê Nouveau : lignes de p√©nalit√©
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ progression/                 # ‚Üê Nouveau module
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ memory-status.service.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ daily-achievements.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ streak-tracker.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ constants.ts            # Tous les niveaux/badges
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sharing/                     # ‚Üê Nouveau module
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ deck-sharing.service.ts
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ url-generator.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ game-controller/            # ‚Üê Renomm√© : logique sans √©tat
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ game-controller.ts      # Logique m√©tier pure
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ flashcard-queue.ts      # File des flashcards
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ penalty-manager.ts      # Gestion des p√©nalit√©s
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sync/                       # ‚Üê Nouveau : synchronisation
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user-progress.service.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sync-strategy.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ offline-queue.ts
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ audio/                      # ‚Üê Nouveau service
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sound-effects.service.ts
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [autres services existants...]
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useFlashcardGame.ts        # ‚Üê Hook principal
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useMemoryStatus.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useDailyProgress.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useGamePenalties.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ store/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ game.store.ts               # √âtat du jeu en cours
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ flashcard.store.ts          # File et √©tat des flashcards
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ progression.store.ts        # ‚Üê Nouveau : progression joueur
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ tests/                          # ‚Üê Tests structur√©s
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ unit/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fsrs-engine.spec.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ flashcard-queue.spec.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ memory-status.spec.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ integration/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ game-flashcard-flow.spec.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ progression-sync.spec.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ e2e/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ user-plays-tetris.cy.ts
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ deck-sharing.cy.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ config/                         # ‚Üê Configuration centralis√©e
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app.config.ts               # Config globale
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ env.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ schema-validators.ts        # Validation des decks
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ constants/                      # ‚Üê D√©pr√©ci√© : tout dans config
‚îÇ       ‚îî‚îÄ‚îÄ [migr√© vers config/]
```

## üèóÔ∏è Architecture Corrig√©e

### 1. **√âtat Centralis√© avec Zustand (Seule Source de V√©rit√©)**

```typescript
// store/game.store.ts
interface GameStore {
  // √âtat observable
  activeGame: GameType | null
  currentFlashcard: FlashcardState | null
  score: number
  bestScore: number
  
  // Actions
  showFlashcard: (card: Flashcard) => void
  handleAnswer: (answer: string) => void
  addPenalty: () => void
}

export const useGameStore = create<GameStore>((set, get) => ({
  // √âtat initial
  activeGame: null,
  currentFlashcard: null,
  score: 0,
  bestScore: 0,
  
  // Actions qui modifient l'√©tat
  showFlashcard: (card) => set({ 
    currentFlashcard: {
      card,
      startTime: Date.now(),
      mode: 'initial'
    }
  }),
  
  handleAnswer: async (answer) => {
    const state = get()
    const correct = answer === state.currentFlashcard?.card.answer
    
    // D√©l√©guer la logique m√©tier au controller
    const result = await gameController.processAnswer(
      state.currentFlashcard,
      answer,
      state.userChoice
    )
    
    set({
      score: state.score + result.points,
      currentFlashcard: null
    })
  }
}))

// services/game-controller/game-controller.ts
class GameController {
  // Pas d'√©tat ! Seulement de la logique m√©tier
  async processAnswer(
    flashcard: FlashcardState,
    answer: string,
    userChoice: 'know' | 'dontknow'
  ): Promise<AnswerResult> {
    const correct = answer === flashcard.card.answer
    const shouldPenalize = !correct || userChoice === 'dontknow'
    
    // Effets de bord
    if (shouldPenalize) {
      await this.penaltyManager.addPenalty()
    }
    
    // Mise √† jour FSRS
    const grade = this.calculateGrade(correct, userChoice)
    await this.fsrsEngine.updateCard(flashcard.card.id, grade)
    
    return {
      correct,
      points: correct && userChoice === 'know' ? 10 : 0,
      penalty: shouldPenalize
    }
  }
}
```

### 2. **Syst√®me d'√âv√©nements pour le Bridge**

```typescript
// modules/games/game-event-system.ts
type GameEventMap = {
  pieceSpawned: { pieceType: string; position: number }
  lineClear: { lines: number }
  gameOver: { score: number }
  pieceLanded: { position: number }
}

class GameEventEmitter extends EventTarget {
  emit<K extends keyof GameEventMap>(
    event: K, 
    detail: GameEventMap[K]
  ): void {
    this.dispatchEvent(new CustomEvent(event, { detail }))
  }
  
  on<K extends keyof GameEventMap>(
    event: K,
    callback: (detail: GameEventMap[K]) => void
  ): void {
    this.addEventListener(event, (e: CustomEvent) => {
      callback(e.detail)
    })
  }
}

// modules/games/flashcard-game-bridge.ts
class FlashcardGameBridge {
  private pieceCount = 0
  private nextThreshold = this.randomThreshold()
  
  constructor(
    private gameEvents: GameEventEmitter,
    private flashcardQueue: FlashcardQueueService
  ) {
    this.setupEventListeners()
  }
  
  private setupEventListeners(): void {
    this.gameEvents.on('pieceSpawned', () => {
      this.pieceCount++
      
      if (this.pieceCount >= this.nextThreshold) {
        this.triggerFlashcard()
        this.pieceCount = 0
        this.nextThreshold = this.randomThreshold()
      }
    })
  }
  
  private randomThreshold(): number {
    return Math.floor(Math.random() * 9) + 3 // 3-11
  }
}
```

### 3. **Service de Synchronisation Cloud**

```typescript
// services/sync/user-progress.service.ts
interface SyncStrategy {
  onUnlock: boolean
  onExit: boolean
  periodic: number // minutes
  manual: boolean
}

class UserProgressService {
  private syncQueue: SyncOperation[] = []
  private lastSync: number = 0
  
  async syncProgress(userId: string): Promise<void> {
    const snapshot = await this.createSnapshot(userId)
    
    try {
      await api.syncUserProgress(userId, snapshot)
      this.lastSync = Date.now()
      await this.clearSyncQueue()
    } catch (error) {
      // Queue pour retry
      this.queueForSync(snapshot)
      throw error
    }
  }
  
  async restoreProgress(userId: string): Promise<ProgressSnapshot> {
    // Tenter le cloud d'abord
    try {
      const cloudSnapshot = await api.getUserProgress(userId)
      await this.mergeWithLocal(cloudSnapshot)
      return cloudSnapshot
    } catch {
      // Fallback local
      return this.getLocalSnapshot(userId)
    }
  }
  
  private async createSnapshot(userId: string): Promise<ProgressSnapshot> {
    return {
      fsrsState: await this.fsrsEngine.exportState(userId),
      memoryLevel: await this.memoryStatus.getLevel(userId),
      dailyBadges: await this.dailyProgress.getBadges(userId),
      decks: await this.deckService.getUserDecks(userId),
      stats: await this.statsService.getStats(userId),
      timestamp: Date.now()
    }
  }
  
  setupAutoSync(strategy: SyncStrategy): void {
    if (strategy.onUnlock) {
      document.addEventListener('visibilitychange', () => {
        if (!document.hidden) this.syncProgress()
      })
    }
    
    if (strategy.onExit) {
      window.addEventListener('beforeunload', () => {
        this.syncProgress() // Best effort
      })
    }
    
    if (strategy.periodic > 0) {
      setInterval(() => this.syncProgress(), strategy.periodic * 60 * 1000)
    }
  }
}
```

### 4. **Validation et S√©curit√© des Decks**

```typescript
// config/schema-validators.ts
import { z } from 'zod'

export const FlashcardSchema = z.object({
  question: z.string().min(1).max(500),
  answer: z.string().min(1).max(500),
  tags: z.array(z.string()).optional()
})

export const DeckSchema = z.object({
  name: z.string().min(1).max(100),
  description: z.string().max(500).optional(),
  cards: z.array(FlashcardSchema).min(1).max(1000),
  public: z.boolean().default(false),
  ownerId: z.string().uuid(),
  version: z.number().default(1),
  createdAt: z.number(),
  updatedAt: z.number()
})

// modules/sharing/deck-validator.service.ts
class DeckValidatorService {
  private readonly bannedPatterns = [
    /<script/i,
    /javascript:/i,
    /on\w+\s*=/i // onclick, onload, etc.
  ]
  
  async validateDeck(deck: unknown): Promise<ValidatedDeck> {
    // Validation de structure
    const parsed = DeckSchema.parse(deck)
    
    // Validation de contenu
    this.validateContent(parsed)
    
    // Sanitization
    return this.sanitizeDeck(parsed)
  }
  
  private validateContent(deck: Deck): void {
    const allText = [
      deck.name,
      deck.description,
      ...deck.cards.flatMap(c => [c.question, c.answer])
    ].join(' ')
    
    for (const pattern of this.bannedPatterns) {
      if (pattern.test(allText)) {
        throw new ValidationError('Contenu non autoris√© d√©tect√©')
      }
    }
  }
  
  private sanitizeDeck(deck: Deck): ValidatedDeck {
    return {
      ...deck,
      name: DOMPurify.sanitize(deck.name),
      description: DOMPurify.sanitize(deck.description || ''),
      cards: deck.cards.map(card => ({
        ...card,
        question: DOMPurify.sanitize(card.question),
        answer: DOMPurify.sanitize(card.answer)
      }))
    }
  }
}

// Partage avec tokens temporaires
class DeckSharingService {
  async createShareLink(
    deckId: string, 
    options: ShareOptions = {}
  ): Promise<ShareLink> {
    const shareToken = nanoid(16)
    const expiresAt = options.expiresIn 
      ? Date.now() + options.expiresIn 
      : null
    
    await api.createShareToken({
      deckId,
      shareToken,
      expiresAt,
      maxUses: options.maxUses
    })
    
    return {
      url: `${window.location.origin}/deck/${shareToken}`,
      expiresAt,
      token: shareToken
    }
  }
}
```

### 5. **Configuration Centralis√©e**

```typescript
// config/app.config.ts
export const APP_CONFIG = {
  flashcards: {
    triggers: {
      minPiecesBetweenCards: 3,
      maxPiecesBetweenCards: 11,
      bossCardThreshold: 7,
      timeoutMs: 30000
    },
    fsrs: {
      defaultInterval: 1,
      easyBonus: 1.3,
      hardFactor: 0.8
    }
  },
  
  scoring: {
    points: {
      perLine: 10,
      perCorrectAnswer: 10,
      combo: {
        multiplier: 1.5,
        threshold: 5
      }
    },
    penalties: {
      wrongAnswer: 'addLine',
      timeout: 'addLine',
      dontKnow: 'addLine'
    }
  },
  
  progression: {
    levels: [
      { id: 'worm', name: 'Ver de terre', icon: 'ü™±', cards: 5, days: 3 },
      { id: 'ant', name: 'Fourmi', icon: 'üêú', cards: 10, days: 3 },
      // ... tous les niveaux
      { id: 'gpt', name: 'ChatGPT', icon: 'ü§ñ', cards: 1000, days: 3 }
    ],
    dailyBadges: [
      { id: 'flash', name: 'Flash', icon: 'üì∏', newCards: 5 },
      { id: 'lightning', name: '√âclair', icon: '‚ö°', newCards: 10 },
      // ... tous les badges
      { id: 'universe', name: 'Univers', icon: 'üåå', newCards: 40 }
    ]
  },
  
  sounds: {
    effects: {
      lineComplete: { file: '/sounds/line-clear.mp3', volume: 0.7 },
      correctAnswer: { file: '/sounds/correct.mp3', volume: 0.8 },
      wrongAnswer: { file: '/sounds/wrong.mp3', volume: 0.6 },
      levelUp: { file: '/sounds/level-up.mp3', volume: 1.0 },
      bossWarning: { file: '/sounds/boss.mp3', volume: 0.9 }
    },
    music: {
      enabled: true,
      volume: 0.5
    }
  },
  
  sync: {
    strategy: {
      onUnlock: true,
      onExit: true,
      periodic: 5, // minutes
      manual: true
    },
    retryPolicy: {
      maxRetries: 3,
      backoff: 'exponential'
    }
  },
  
  sharing: {
    maxDeckSize: 1000,
    requiresPurchase: true,
    tokenExpiry: 7 * 24 * 60 * 60 * 1000 // 7 jours
  }
}
```

### 6. **Tests Structur√©s**

```typescript
// tests/unit/fsrs-engine.spec.ts
import { describe, it, expect } from 'vitest'
import { FSRSEngine } from '@/modules/flashcards/fsrs/fsrs-engine'

describe('FSRSEngine', () => {
  it('should calculate next review correctly', () => {
    const engine = new FSRSEngine()
    const card = { stability: 2.5, difficulty: 0.3 }
    const result = engine.calculateNextReview(card, 'good')
    
    expect(result.interval).toBeGreaterThan(2)
    expect(result.nextReview).toBeInstanceOf(Date)
  })
  
  it('should handle boss cards properly', () => {
    const engine = new FSRSEngine()
    const difficultCard = { failureCount: 10 }
    
    expect(engine.isBossCard(difficultCard)).toBe(true)
  })
})

// tests/integration/game-flashcard-flow.spec.ts
import { renderHook, act } from '@testing-library/react'
import { useFlashcardGame } from '@/hooks/useFlashcardGame'

describe('Game-Flashcard Integration', () => {
  it('should trigger flashcard after threshold pieces', async () => {
    const { result } = renderHook(() => useFlashcardGame('tetris'))
    
    // Simuler plusieurs pi√®ces
    for (let i = 0; i < 5; i++) {
      act(() => {
        result.current.gameEvents.emit('pieceSpawned', {})
      })
    }
    
    expect(result.current.currentFlashcard).toBeTruthy()
  })
})

// tests/e2e/user-plays-tetris.cy.ts
describe('User plays Tetris with flashcards', () => {
  it('should show flashcard and apply penalty on wrong answer', () => {
    cy.visit('/game/tetris')
    cy.get('[data-testid="start-game"]').click()
    
    // Attendre la premi√®re flashcard
    cy.get('[data-testid="flashcard-modal"]', { timeout: 30000 })
      .should('be.visible')
    
    // R√©pondre "Je sais" puis se tromper
    cy.get('[data-testid="i-know"]').click()
    cy.get('[data-testid="wrong-answer"]').click()
    
    // V√©rifier la p√©nalit√©
    cy.get('[data-testid="game-board"]')
      .should('have.attr', 'data-penalty-lines', '1')
  })
})
```